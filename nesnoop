#!/usr/bin/bpftrace

#include <net/sock.h>

kprobe:tcp_connect, kprobe:tcp_close
/comm != "sshd" && arg0 != 0/ { @sk[tid] = arg0 }
kprobe:tcp_sendmsg, kprobe:tcp_recvmsg
/comm != "sshd" && arg1 != 0/ { @sk[tid] = arg1 }

kprobe:tcp_connect,
kprobe:tcp_sendmsg,
kprobe:tcp_recvmsg,
kprobe:tcp_close
/@sk[tid]/
{
	$sk = (struct sock *)@sk[tid];
	$sk_common = $sk->__sk_common;
	/* NB: This should be avoided */

	time("%s "); /* %s = seconds */
	printf("%s: %s[%d] running as user %d, group %d [dest: %d]\n",
		probe, comm, pid, uid, gid, $sk_common.skc_daddr);
	/* NB: Accessing skc_daddr forces bpf to copy sk_common on to stack
	 *     which results in exceeding 512 byte stack limit
	 * NB: We will see in the next commit that the better approach is to
	 *     use the header macros for accessing the same data
	 */

	delete(@sk[tid]);
}

END { clear(@sk) }
